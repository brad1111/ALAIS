#/bin/bash
##Find RAM
TOTAL_RAM=2048
##End Find Ram
##Find UEFI
if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]
    modprobe -r -q efivars || true #Only on a MAC computer
    else
    modprobe -q efivarfs
fi
UEFI=0 #Default is BIOS
if [[ -d "/sys/firmware/efi/" ]]; then
    ##Mount efivarfs if not already mounted
    if [[ -z $(mount | grep /sys/firmware/efi/efivarfs) ]]; then; mount -t efivarfs efivarfs /sys/firmware/efi/efivars
    UEFI=1
    echo Currently in UEFI mode
fi
##End Find UEFI
##Start PACMAN
is_package_installed() {
    for PKG in $PKG; do
        pacman -Q $CHKPKGS &> /dev/null && return 0;
    done
    return 1
}


package_install() { 
    for PKG in ${1}; do
        if ! is_package_installed "${PKG}" ; then
            pacman -S --noconfirm --needed ${PKG}
        fi
    done
}

##END PACMAN
check_connection() {
ping -q -w 1 -c 1 `ip r | grep default | awk 'NR==1 {print $3}'` &> /dev/null && return 1 || return 0
}
if check_connection(); then
    echo Please connect to a network
    read
    exit 1
fi

BOOL_AUTOINST=FALSE
if [[ -f `pwd`/autoinstall ]]; then #Checks for AutoInstall script for arch linux
    source autoinstall
fi
####Config Section
BOOL_MENUCOMPLETE=FALSE
##KEYMAP Section
while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
    if [[ $BOOL_AUTOINST == FALSE ]]; then
        clear
        echo What keymap do you want (DEFAULT=us):
        read -p "Keymap:" KEYMAP
        if [[ $KEYMAP == ]]; then
            KEYMAP=us
        fi
        BOOL_MENUCOMPLETE=TRUE
    else
        BOOL_MENUCOMPLETE=TRUE
    fi
done

loadkeys $KEYMAP

if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo What editor do you want as default?
        read -p "Editor:" EDITOR
        if [[ $EDITOR == emacs ]]; then
            EMAC=emacs
            BOOL_MENUCOMPLETE=TRUE
        elif [[ $EDITOR == vim ]]; then
            VIM=vim
            BOOL_MENUCOMPLETE=TRUE
        elif [[ $EDITOR == zile ]]; then
            ZILE=zile
            BOOL_MENUCOMPLETE=TRUE
        elif [[ $EDITOR == nano ]]; then
        BOOL_MENUCOMPLETE=TRUE
        elif [[ $EDITOR == vi ]]; then
        BOOL_MENUCOMPLETE=TRUE
        else
        echo Please enter a valid answer
        read
        fi
    done
fi
package_install() "$EDITOR"

####No Mirror Conf Yet
#if [[ $BOOL_AUTOINST == FALSE ]]; then
#    BOOL_MENUCOMPLETE=FALSE
#    while [[ $BOOl_MENUCOMPLETE == FALSE ]]; do
#        
#    done
#fi


##Choose Device
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; then
        clear
        echo Showing all Devices
        lsblk
        echo Ending showing all devices
        echo --------------------------
        echo What device (hard drive letter a = disk 0) do you want to install to?
        read DEVICE
        if [[ $DEVICE == "/dev/sd"* ]]; then
            BOOL_MENUCOMPLETE=TRUE
        else
            echo Please enter a valid answer
            read
        fi
    done
 fi
 
 ######################Move ME!
# DEVICE_PARTITION_TABLE=NULL
# DEVICE_ESP=
# DEVICE_SWAP=
# DEVICE_ROOT=
# if [[ $BOOL_AUTOINST == FALSE ]]; then; partitioner=parted; fi
# partition_man()
# {
#     if [[ partitioner == parted ]]; then
#         if [[ %1 == mbr ]]; then
#             parted mklabel msdos
#             DEVICE_PARTITION_TABLE=msdos
#         elif [[ %1 == gpt ]]; then
#             parted mklabel gpt
#             DEVICE_PARTITION_TABLE=gpt
#         elif [[ %1 == esp ]]; then
#             parted mkpart primary fat32 512MB
#             DEVICE_ESP=/dev/sd{$device}1
#         elif [[ %1 == swap ]]; then
#             parted mkpart primary linux-swap $TOTAL_RAM
#             if [[ $DEVICE_ESP ]]; then; DEVICE_SWAP=/dev/sd{$device}1; else; DEVICE_SWAP=/dev/sd{$device}2; fi
#         elif [[ %1 == root ]]; then
#             parted mkpart primary ext4 100%
#             if [[ $DEVICE_SWAP == /dev/sd{$device}1 ]]; then; DEVICE_ROOT=/dev/sd{$device}2; elif [[ $DEVICE_SWAP == /dev/sd{$device}2 ]]; then; DEVICE_ROOT=/dev/sd{$device}3; else; echo An Error occured partitioning Root; read; exit 1; fi
#         fi
#     fi
# }
# 

##Choose Partition
#if [[ $BOOL_AUTOINST == FALSE ]]; then
#  BOOL_MENUCOMPLETE=FALSE 
#  while [[ $BOOL_MENUCOMPLETE == FALSE ]]; then
#        clear
#        ###UEFI Partition
#        if [[ UEFI == 1 ]]; then
#            partition_man "esp"
#       fi
#        partition_man "swap"
#        partition_man "root"
#        
#  done
#fi

##SetFstab
if [[ $BOOL_AUTOINST == FALSE ]]; then
    if [[ -n $(dmidecode --type 1 | grep VirtualBox) ]]; then
        LTS=TRUE
    elif [[ -n $(dmidecode --type 1 | grep VMware) ]]; then
        LTS=TRUE
    fi
    if [[ !UEFI ]]; then
        FSTABTYPE=PARTUUID
    else
        FSTABTYPE=UUID
    fi
fi

##Language
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo What language do you want (e.g. en_US or en_GB)
        read language
        if [[ language == *"_"* ]]; then
            BOOL_MENUCOMPLETE=TRUE
        else
            echo Please enter a valid language code
            read
        fi
    done
fi

##Timezone
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo What timezone do you want (e.g. Europe/London, US/Pacific or UTC)
        read timezone
        if [[ timezone == */* ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == UTC ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == CET ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == CST6CDT ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Cuba ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == EET ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Egypt ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Eire ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == EST ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == EST5EDT ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Factory ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == GB ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == GB-Eire ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == "GMT"* ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Greenwich ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Hongkong ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == HST ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Iceland ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Iran ]]; then BOOL_MENUCOMPLETE=TRUE
        #elif [[ timezone == iso3166.tab ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Israel ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Jamaica ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Japan ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Kwajalein ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Libya ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == MET ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == "MST"* ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Navajo ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == NZ ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == NZ-CHAT ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Poland ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Portugal ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == posixrules ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == PRC ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == PSR8PDT ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == ROC ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == ROK ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Singapore ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Turkey ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == UCT ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Universal ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == W-SU ]]; then BOOL_MENUCOMPLETE=TRUE
        elif [[ timezone == Zulu ]]; then BOOL_MENUCOMPLETE=TRUE
        else
            echo Please enter a valid timezone
            read
        fi
    done
fi

##Set hardware-clock
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo Please set the hardware clock (UTC or Localtime) (UTC Recommended, Localtime if dualbooting with Windows)
        read hwclockvar
        if [[ $hwclockvar == UTC ]]; then BOOL_MENUCOMPLETE=FALSE
        elif [[ $hwclockvar == Localtime ]]; then BOOL_MENUCOMPLETE=False
        else
            echo Please enter a valid hwclock value
            read
        fi
    done
fi

##Hostname
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOl_MENUCOMPLETE == FALSE ]]; do
        clear
        echo Please set the hostname for your new system
        read hostname
        break
    done
fi

##Network manager thing
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo Please set your network manager (Networkmanager, Connman, or Wicd)
        read networkman
        if [[ $networkman == Networkmanager ]]; then break
        elif [[ $networkman == ConnMan ]]; then break
        elif [[ $networkman == wicd ]]; then break
        else
            echo Please enter a valid network manager
            read
        fi
    done
fi

##Password (PLEASE BE TEMPORARY) For now
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo Please enter a TEMPORARY password that you will change later whilst you are logged in (this is because it is insecure)
        read password
        break
    done
fi

##Post Config Wizard
PConfWiz()
{
    #BasicSetup
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local basicsetupYN
        echo Do you want basic setup (bc, rsync, mlocate bash-completeion pkgstats, ntp, avahi, alsa, pulseaudio, file systems) [Y/N]
        read basicsetup
        if [[ $basicsetup == Y ]]; then
            BOOL_BASICSETUP=TRUE
            break
        elif [[ $basicsetup == N ]]; then
            BOOL_BASICSETUP=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #SSH
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local sshYN
        echo Do you want SSH? [Y/N]
        read sshYN
        if [[ sshYN == Y ]]; then
            BOOL_SSH=TRUE
            break
        elif [[ sshYN == N ]]; then
            BOOL_SSH=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #NFS
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local nfsYN
        echo Do you want NFS? [Y/N]
        read nfsYN
        if [[ nfsYN == Y ]]; then
            BOOL_NFS=TRUE
            break
        elif [[ nfsYN == N ]]; then
            BOOL_NFS=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #Samba
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local sambaYN
        echo Do you want Samba? [Y/N]
        read sambaYN
        if [[ sambaYN == Y ]]; then
            BOOL_SAMBA=TRUE
            break
        elif [[ sambaYN == N ]]; then
            BOOL_SAMBA=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #Readahead
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local readaheadYN
        echo Do you want Readahead? [Y/N]
        read readaheadYN
        if [[ readaheadYN == Y ]]; then
            BOOL_READAHEAD=TRUE
            break
        elif [[ readaheadYN == N ]]; then
            BOOL_READAHEAD=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #Fontconfig
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local fontconfigOPTION
        echo What fontconfig [Normal, Infinality, Ubuntu] [1,2,3]
        read fontconfigOPTION
        if [[ fontconfigOPTION == 1 ]]; then
            BOOL_FONTCONFIG=NORM
            break
        elif [[ fontconfigOPTION == 2 ]]; then
            BOOL_FONTCONFIG=INF
            break
        elif [[ fontconfigOPTION == 3 ]]; then
            BOOL_FONTCONFIG=UBUNTU
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    #XORG
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        local xorgYN
        echo Do you want XORG? [Y/N]
        read xorgYN
        if [[ xorgYN == Y ]]; then
            BOOL_XORG=TRUE
            break
        elif [[ xorgYN == N ]]; then
            BOOL_XORG=FALSE
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
    
}

##Post config
if [[ $BOOL_AUTOINST == FALSE ]]; then
    BOOL_MENUCOMPLETE=FALSE
    while [[ $BOOL_MENUCOMPLETE == FALSE ]]; do
        clear
        echo Do you want to use a wizard to setup post-install, or just choose the applications? [Y/N]
        read temp_postconfig
        if [[ $temp_postconfig == Y ]]; then
            PConfWiz
            break
        elif [[ $temp_postconfig == N ]]; then
            break
        else
            echo Please enter a valid answer [Y/N]
            read
        fi
    done
fi

####Config End
